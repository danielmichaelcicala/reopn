\documentclass{amsart}
\linespread{2}
\input{assets/preamble.tex}

\begin{document}
\input{assets/frontMatter.tex}

%% ===================================
%% Introduction
%% ===================================
\section{Introduction}
\label{sec:Intro}


%% ===================================
%% Rewriting in Topoi
%% ===================================
\section{Rewriting in topoi}
\label{sec:RewriteTopoi}

The topic of double pushout rewriting is well represented in
the literature. Here, we cover the basics and set our
notation and convention. Experts can skip to the next
section. Novices have many suitable choices to supplement
this review, though we suggest Lack and Sobocinski's
axiomatization of rewriting in adhesive categories
\cite{LackSobo_Adhesive}.

Rewriting starts with the notion of a \df{rewrite rule}, or
simply \df{rule}. In its most general form, a rule is a span
\[
  \ell \gets k \to r
\]
in a topos. For us, the arrows are of the span are always
monic and, whenever possible, unnamed.

The conceit of a rule is that $ r $ replaces $ \ell $ while
$ k $ identifies a subsystem of $ \ell $ that remains
fixed. For example, suppose we were modeling some system
using graphs where self-loops are negligable. For example,
consider a model of the internet as a graph with websites
for nodes and links for edges. If we wished to ignore links
from a websites to itself, we can introduce a rule
that replaces a loop on a node with that node
\input{assets/squashLoopRule.tex}

To \emph{apply} a rule $ \ell \gets k \to r $ to an object
$ \ell' $, we require an arrow $ \ell \to \ell' $ such that
there exists a \df{pushout complement}, an object $ d $
fitting into a pushout diagram \input{assets/pushoutComplement} 
A pushout complement need not exist, but when it does and
the map $ k \to \ell $ is monic, then it is unique up to
isomorphism \cite[Lem.~15]{LackSobo_Adhesive}.

Each application of a rule begets a new rule.

\begin{definition}[Derived rule] \label{def:derived-rule}
  Applying a rule $ \ell \gets k \to r $ to an object $ g $
  induces a \df{derived rule} $ \ell' \gets k' \to r' $ that
  fits into the bottom row of the double pushout diagram
  \input{assets/derivedRule.tex}
\end{definition}

The arrows of derived rule are also monic because pushouts
in topoi preserve monics
\cite[Lem.~12]{lack-sobo_adhesive-cats}. Interpret this
diagram as follows: the map $ \ell \to \ell' $ selects a
copy of $ \ell $ inside $ \ell' $ and that copy is replaced
by $ r $ resulting in the new object $ r' $. 

To illustrate, let us return to the internet modeled using
graphs and negligable self-loops.  Then we can
apply Rule \eqref{eq:squash-loop-rule} to any node with a
loop. This application is captured with the double pushout
diagram \input{assets/squashLoopRuleApplied.tex}

The map $ m $ selects the self-loop and corresponding node
in the bottom left graph. A pushout complement exists,
meaning that the rule can be applied and so the loop is
removed. The result is the bottom right graph.  The reader
can check that the two squares are pushouts.

Specialists is a particular sort of system spend time
understanding the its rewrite rules. Resistor circuits have
parallel, series, and star rules. Other systems have their
own versions. Therefore, we consider a system equipped with
a set of rules. 

\begin{definition}[Grammar] \label{def:grammar} A topos
  $ \T $ together with a finite set $ P $ of rules
  $ \{ \spn{\ell_j}{k_j}{r_j} \} $ in $ \T $ is a
  \df{grammar}. A morphisms of grammars
  $ ( \cat{S} , P ) \to ( \T , Q ) $ is a pullback and pushout
  preserving functor $ F \from \cat{S} \to \T $ such that for
  each rule $ \xspn{\ell}{f}{k}{g}{r} $ in $ P $, the rule
  $ \xspn{F\ell}{Ff}{Fk}{Fg}{Fr} $ is in $ Q $. Together
  these form a category $ \Gram $.
\end{definition}

Like a seed, from a grammar grows something entirely new
called the \emph{language}. The language contains all necessary
information about the syntax of a system, so naturally, it
is the thing to study. The potential complexity of a
language makes this a difficult task, so we instead turn to
a more accessible proxy called the \emph{rewrite
  relation}. This relation captures the relationship between
the many sytactical componenets of a language.  

Constructing the rewrite relation requires several steps.  A
grammar $ ( \T , P ) $ induces a relation
$ \dderiv{}{} $ on the objects of $ \T $ defined by
$ \dderiv{g}{h} $ whenever there exists a rule
$ \spn{g}{d}{h} $ derived from a production in $ P $. For
instance, the above double pushout diagram would relate
\input{assets/dpoRelates.tex}

But $ \dderiv{}{} $ is too small to capture the full
behavior of the language.  For one, it is not true in
general that $ \dderiv{g}{g} $ holds. Also, $ \dderiv{}{} $
does not capture multi-step rewrites. That is, there may be
derived rules witnessing $ \dderiv{g}{g'} $ and
$ \dderiv{g'}{g''} $ but not a derived rule witnessing
$ \dderiv{g}{g''} $. We want to relate a pair of objects if
one can be rewritten into another using a finite sequence of
rules that are either in $ P $ or derived from a rule in
$ P $. Therefore, we define the \df{rewrite relation} to be
the reflexive and transitive closure of $ \dderiv{}{} $

After we introduce a grammar for structured cospans in Section
\ref{sec:}, we show that constructing it is functorial.

%% ===========================================
\section{Structured cospans form a topos}
\label{sec:StructureOfStrCsp}
%% ===========================================

Having discussed rewriting in a topos, in order to introduce
the rewriting of structured cospans, we better ensure that
they form a topos. Indeed, we do this after recalling their
definition.

Baez and Courser introduced structured cospans
\cite{bc_strCsp} to serve as a syntax for open systems. We
use the term `system' broadly and avoid giving a precise
definition.  By `open', we mean that compatible systems can
be connected to form a larger system.  For example, a vacuum
cleaner can connected to the electrical grid via an
electrical socket. Or, a pulley system can connect to a
mechanical motor.

In order to form a topos out of structured cospans, we require stronger conditions than assumed by Baez and Courser.

%% define structured cospans
\begin{definition}
  Fix an adjunction $$\adjunction{\X}{L}{R}{\A}$$ between
  (elementary) topoi with $ L $ preserving finite
  limits. An \df{$ L $-structured
    cospan}, or simply \df{structured cospan}, is any cospan
  in $ \X $ of the form $ La \to x \gets Lb $.    
\end{definition}

How does the structured cospan syntax map onto an open
system? The apex $x$ of the cospan represents the system
itself.  The legs of the cospan, $ La \to x $ and
$ Lb \to x $, select the inputs $ La $ and outputs $ Lb $ of
$ x $. These legs endow structured cospans with the ability
to connect together. Given $ La \to x \gets Lb $ and
$ Lb \to y \gets Lc $, we form the \emph{composite}
structured cospan $ La \to x+_{Lb}y \gets Lc $. Interpret
the pushout $ x+_{Lb}y $ as an object obtained by glueing
$ x $ to $ y $ along their common interface $ Lb $. The
reason we call $La \gets x+_{Lb}y \to Lc$ the `composite' is
because a natural way to emphasize this connectability is by
defining a category in which structured cospans are the
arrows.

%% define category w str cospans as arrows
\begin{definition}
  Given an adjunction $$\adjunction{\X}{L}{R}{\A}$$ between
  (elementary) topoi with $ L $ preserving finite limits,
  denote by $ _L \Csp $ the category whose objects are those
  of $ \A $ and arrows from $ a $ to $ b $ are structured
  cospans $ La \to x \gets Lb $.  
\end{definition}

Of course, $ _L \Csp $ does not require the full strength of
those conditions to form a category---Baez and Courser do
not ask this much---but remember, we are aiming to form a
topos of structured cospans.

%% example: open graphs
\begin{example}
  Consider the
  adjunction $$\adjunction{\Graph}{L}{R}{\Set}$$ with $ L $
  the discrete graph functor and $ R $ the functor that
  forgets the graph edges.  Structured cospans for this
  adjunction are open graphs, that is graphs equipped with
  two subset of nodes, one set interpretted as inputs and
  the other as outputs. These ``interface'' sets need not be
  disjoint. For example, the pair of open graphs
  \input{assets/openGraph1.tex} are composed
  by glueing like-nodes together
  \input{assets/openGraph2.tex}
\end{example}

Let us pause for a moment to recall that, in Section
\ref{sec:RewriteTopoi}, we showed that rewriting operates on
the \emph{objects} of a topos, not the arrows.  To comply
with this, our immediate tasks become to define a category
where structured cospans are objects and then show that
category to be a topos.

% define L-structured cospan morphism
\begin{definition} \label{df:morph-of-strcsp}
  Let $ L \dashv R $ be an adjunction between topoi where
  $ L $ preserves finite limits. There is a category
  $ _L \StrCsp $ whose objects are $ L $-structured cospans
  and arrows from $ La \to x \gets Lb $ to
  $ Lc \to y \gets Ld $ are triple of arrows $ ( f,g,h ) $
  fitting into the commuting diagram
  \input{assets/morphismStrCsp.tex}
\end{definition}

%% structured cospans form a topos
\begin{theorem} \label{thm:strcsp-istopos}
  Given an adjunction $$\adjunction{\X}{L}{R}{\A}$$ between
  topoi with $ L $ preserving finite limits, the category
  $ _{L}\StrCsp $ is a topos.
\end{theorem}
\begin{proof}
  By adjointness, $ _{L}\StrCsp $ is equivalent to the
  category whose objects are cospans of form
  $ a \to Rx \gets b $ and morphisms are triples
  $ ( f,g,h ) $ fitting into the commuting diagram
  \input{assets/morphismRStrCsp.tex} This, in turn, is
  equivalent to the comma category
  $ ( \A \times \A \downarrow \Delta R ) $ where
  $ \Delta \from \A \to \A \times \A $ is the diagonal
  functor, a right adjoint. Hence, $ \Delta R $ is a right
  adjoint making $ ( \A \times \A \downarrow \Delta R ) $
  an Artin glueing \cite{Wraith_ArtinGlue}, therefore
  a topos.
\end{proof}

Not only is $ _L\StrCsp $ a topos, but it is constructed functorially.

\begin{theorem} \label{thm:strcsp-isfunctorial} Denote by
  $ \Topos $ the category whose objects are topoi and whose
  arrows from $ \X $ to $ \A $ are adjoint
  pairs $$\adjunction{\X}{L}{R}{\A}$$ where $ L $ preserves
  finite limits. There is a functor
  \[
    _{(-)}\StrCsp_{(-)}
      \from [\bullet \to \bullet, \Topos ]
      \to   \Topos
  \]
  defined by \input{assets/functorialStrCsp1.tex} which is
  in turn given by \input{assets/functorialStrCsp2.tex} and
  \input{assets/functorialStrCsp3.tex}
\end{theorem}
\begin{proof}
  In light of Theorem \ref{thm:strcsp-istopos}, it suffices
  to show that $ \Theta \dashv \Theta' $ gives a geometric
  morphism.

  Denote the structured cospans
  $$[ m,n ] \colon La \to x \gets Lb$$ in $ _L\StrCsp $
  by $ \ell $ and $$[m',n'] \colon L'a' \to x' \gets L'b'$$ in
  $ _{ L' }\StrCsp $ by $ \ell' $. Denote the unit and
  counit for $F \dashv G$ by $ \eta $, $ \varepsilon $ and
  for $ F' \dashv G' $ by $ \eta' $, $ \varepsilon' $.  The
  assignments
  
  \begin{align*}
    \left( (f,g,h)\from\ell\to\Theta'\ell' \right)
      & \mapsto
        \left( (\epsilon'\circ F'f,
        \epsilon\circ Fg,
        \epsilon'\circ F'h )
        \from\Theta\ell\to\ell'\right) \\
    \left( (f',g',h')\from\Theta\ell\to\ell'\right)
      & \mapsto
        \left( (G'f'\circ\eta',Gg'\circ\eta,G'h'\circ\eta')
        \from\ell\to\Theta'\ell'\right) 
  \end{align*}
  
  give a bijection
  $ \hom (\Theta\ell,\ell') \simeq \hom (\ell,\Theta'\ell'
  )$. Moreover, it is natural in $\ell$ and $\ell'$. This
  rests on the natural maps $\eta$, $\epsilon$, $\eta'$, and
  $\epsilon'$. The left adjoint $\Theta'$ preserves finite
  limits because they are taken pointwise and $ L $, $ F $,
  and $ F' $ all preserve finite limits.
\end{proof}

With this theorem, we have highlighted categories of the
form $ _L\StrCsp $ where $ L $ runs through finite limit
preserving left adjoints. These \df{structured cospan
  categories} fit into a 2-category $ \SStrCsp $. A 1-arrow
from $ _L\StrCsp \to _{L'}\StrCsp $ is a pair of finitely
continuous and cocontinuous functors $ F \from \X \to \X' $
and $ G \from \A \to \A' $ fitting into the commuting
diagram
\input{assets/StrCsp_1Arrow.tex}. A 2-arrow from $
(F,G) \To (F',G') $ is a pair of natural transformations $
\alpha \from F \To F' $ and $ \beta \from G \to G'$. 

%% =========================================
\section{Rewriting structured cospans}
\label{sec:RewritingStrCsp}
%% =========================================

\Daniel{Generalize gadducci/heckle's theorem.  Place it into
  the ACT context.}

\Daniel{require that L have monic counit from the start}


In Definition \ref{def:grammar}, we defined a category
$ \Gram $ where an object is a topos paired with a set of
rewrite rules and an arrow $ (\T , P) \to ( \T' , P' )$ is a
rule-preserving functor $ \T \to \T' $.  Our interest now
lies in the subcategory of structured cospan grammars
$ \StrCspGram $ that is full on the grammars where $ \T $ is
a structured cospan category and $ P $ is a set of structured
cospan rewrite rules.   

It is on this category $ \StrCspGram $ that we define the
\emph{language functor}
$ \Lang \from \StrCspGram \to \DblCat $ which encodes the
rewrite relation to each grammar. The ``language functor''
is an appropriate name as it provides \emph{(i)} the terms
formed by connecting together open systems (instead of
concatenating units of syntax in linguistics) and \emph{(ii)}
the rules governing how to interchange open systems (instead
of parts of speech). To help visualize this, we sketch a
simple example.

\begin{example}
  Starting with the discrete graph adjunction
  \[
    \adjunction{\RGraph}{L}{R}{\Set}
  \]
  for which $ _L \StrCsp $ is the category of open graphs,
  consider a grammar defined by the single rule
  \input{assets/singleRuleGrammar1.tex} The language
  associated to this grammar consists of all open
  graphs. The rewrite relation $ \deriv{g}{h} $ means that
  we obtained $ h $ by removing loops from $ g $. We
  illustrate this with the following square in the double
  category $ \Lang ( _L \StrCsp , P )
  $. \input{assets/singleRuleGrammar2.tex}
\end{example}

We construct $ \Lang $ in two steps. First, we apply a
functor $ D \from \StrCspGram \to \StrCspGram $ that sends a
grammar $ ( _L \StrCsp , P ) $ to all of the rewrite rules
derived from $ P $. Second, we apply a functor
$ S \from \StrCspGram \to \DblCat $. that generates a double
category on the squares obtained from the rewrite rules of a
grammar $ ( _L \StrCsp , P ) $. In this way, we get the
language of a grammar as a double category where the squares
are the rewrite rules.  The next lemma defines $ D $ and
extracts some of its properties.

\begin{lemma}
  There is an idempotent functor
  $ D \from \StrCspGram \to \StrCspGram $ defined as
  follows. On objects define $ D ( _{L}\StrCsp , P ) $ to be
  the grammar $ ( _{L} \StrCsp , P_D) $, where $ P_D $
  consists of all rules $ \spn{g}{h}{d} $ witnessing the
  relation $ \dderiv{g}{h} $ with respect to
  $ ( _{L}\StrCsp , P ) $. On arrows, define
  $ DF \from D( _{L}\StrCsp , P ) \to D( _{L'}\StrCsp , Q )
  $ to be $ F $.  Moreover, the identity on $ \StrCspGram $
  is a subfunctor of $ D $.
\end{lemma}

\begin{proof}
  That $ D ( _{L}\StrCsp , P ) $ actually gives a grammar
  follows from the fact that pushouts respect monics in a
  topos \cite[Lem.~12]{LackSobo_Adhesive}.
  
  To show that $ \D $ is idempotent, we show that for any
  grammar $ ( _{L}\StrCsp , P ) $, we have
  $ D ( _{L}\StrCsp , P ) = DD ( _{L}\StrCsp , P ) $.  Rules
  in $ DD ( _{L}\StrCsp , P ) $ appear in the bottom row of a
  double pushout diagram whose top row is a rule in
  $ D ( _{L}\StrCsp , P ) $, which in turn is the bottom row
  of a double pushout diagram whose top row is in
  $ ( _{L}\StrCsp , P ) $. Thus, a rule in
  $ DD ( _{L}\StrCsp , P ) $ is the bottom row of a double
  pushout diagram whose top row is in
  $ ( _{L}\StrCsp , P ) $. See Figure \ref{fig:idempotentD}.

  \input{assets/indempotentD.tex}

  The identity is a subfunctor of $ D $ because the identity
  on any rule $ \spn{\ell}{k}{r} $ in
  $ ( _{L}\StrCsp , P ) $ induces $ \dderiv{\ell}{r} $.
  Hence there is a monomorphism
  \[
    ( _L \StrCsp , P ) \to
    D ( _L \StrCsp , P )
  \]
  induced from the identity functor on $ _L\StrCsp $.
\end{proof}

Plainly stated, $ D $ sends a grammar to a new grammar
consisting of all derived rules.  That $ D $ is idempotent
means that a rule derived from $ P $ can be derived
directly, hence multiple applications of $ D $ are
unnecessary.  That the identity is a subfunctor of $ D $
means that set of the derived rules $ P_D $ contains rules
in $ P $.

The next stage in defining $ \Lang $ is to define
$ S \from \StrCspGram \to \DblCat $. On objects, let
$ S ( _L \StrCsp , P ) $ be the sub-double category of
$ _L \SSStrCsp $ generated by the rules in $ P $ considered
as squares.  On arrows, $ S $ sends
\[
  F \from ( _{L}\StrCsp , P ) \to ( _{L'} \StrCsp , P' )
\]
to the double functor defined that extends the mapping
between the generators of $ S ( _{L}\StrCsp , P ) $ and
$ S ( _{L'}\StrCsp , P' ) $.  This preserves composition because
$ F $ preserves pullbacks and pushouts. 

\begin{definition}(Language of a grammar)
  The \df{language functor} is defined to be
  $ \Lang \coloneqq SD $. 
\end{definition}

To witness the rewriting relation on a closed system as a
square in a double category, we require this next lemma
that formalizes the analogy between rewriting the disjoint
union of systems and tensoring squares.

\begin{lemma} \label{thm:rewrite-rel-is-additive}
  If $ \deriv{x}{y} $ and $ \deriv{x'}{y'} $, then
  $ \deriv{x+x'}{y+y'} $
\end{lemma}

\begin{proof}
  If the derivation $ \deriv{x}{y} $ comes from a string of
  double pushout diagrams
  \input{assets/rewriteRelAdditive1.tex} and the derivation
  $ \deriv{x'}{y'} $ comes from a string of double pushout
  diagrams \input{assets/rewriteRelAdditive2.tex} realize
  $ \deriv{x+x'}{y+y'} $ by
  \input{assets/rewriteRelAdditive3.tex}
\end{proof}

%% =====================================================
\section{A double category of structured cospan rewrites}
\label{sec:DblCat}
%% =====================================================

\Daniel{Cover what a grammar is and organize them into a double
category a la FineRewrite. Uncertain to include: interchange
law, symmetric monoidal structure. Just point to thesis?
Dno't call things FineRewrite, just Rewrite.}

Because $ _L\StrCsp $, the category of structured cospans
and their morphisms, is a topos, we are ensured that
rewriting structured cospans have a nice theory of rewriting
a l\'{a} adhesive categories \cite{LackSobo_Adhesive}.
The goal of this section is to define a double category whose squares
are rewrites of structured cospans.  The rough idea is
that this double category, denoted $ _L\RRRewrite $, has
``interface'' types for objects, structured cospans for
horizontal arrows, isomorphisms of interface objects for
vertical arrows, and rewrite rules of structured
cospans for squares. We prove in Proposition
\ref{thm:fine-rewrite-double-cat} that $ _L\RRRewrite $
actually is a double category. The first step to proving
this is to ensure the rewrite rules are suitable squares for
our double category, we define them as follows.

\begin{definition}[Rewrite]
  A \df{rewrite rule of structured cospans} is an
  isomorphism class of spans of structured cospans of the
  form \input{assets/spanStrCsp.tex} The marked arrows are
  monic.
\end{definition}

Working with isomorphism classes is a technical point.  The
squares of a double category are subject to two composition
operations. Below, we define horizontal composition using
pushout, as is standard with cospan categories, and vertical
composition uses pullback, as is standard in span
categories.  But pushouts and pullbacks are defined only up
to isomorphism and there are no higher order arrows
traversing the squares in a double category. Therefore, we
must work with isomorphism classes of structured cospan
rewrite rules.

The \df{horizontal composition} of rewrite rules is given by
\input{assets/horComposition1.tex} We interpret this as
taking composable open systems, each undergoing a rewrite,
and combining them into a single open system undergoing a
single rewrite.

The \df{vertical composition} of rewrite rules is given by
\input{assets/vertComposition.tex} We interpret this as an open
system undergoing a two-step rewrite.  

Here, we must make two technical points. The first is that
horizontal and vertical composition are defined on
representatives of isomorphism classes and one can show that
operation is well-defined. The second is that we require the
monic arrows to be preserved, which we show in Proposition
\ref{thm:comp-preserve-monic} below. To prove this
proposition, we requires the following lemma.

\begin{lemma}
  \label{thm:quotient-map-monic-pushout}
  The diagram \input{assets/quotientMapMonicPushout1.tex}
  induces a pushout
  \input{assets/quotientMapMonicPushout2.tex} such that the
  canonical arrows $ \gamma $ and $ \gamma' $ are monic.
\end{lemma}

\begin{proof}
  The universal property of coproducts implies
  that $ \gamma $ factors through $ x' + z $ as in
  the diagram \input{assets/quotientMapMonicPushout3.tex}
   
  It is straightforward to check that both squares are
  pushouts. By Lemma \ref{lem:adhesive-properties}, it
  follows that $ \gamma $ is monic.

  Diagram \ref{eq:qmmp-2} commutes because of the universal
  property of coproducts.  To see that it is a pushout,
  arrange a cocone
  \input{assets/quotientMapMonicPushout4.tex}
  
  Denote by $ \iota_x $ any map that includes $ x $.  Then
  $ \psi' \iota_{x'} $, $ \psi' \iota_{z'} $, and $ c $ form
  a cocone under the span $ x' \gets y' \to z' $ from the
  bottom face of Diagram \ref{eq:qmmp-1}. This induces the
  canonical map $ \psi'' \from x'+_{y'} z' \to c $. It
  follows that
  $ \psi' \iota_{x'} = \psi'' \rho' \iota_{x'} $ and
  $ \psi' \iota_{z'} = \psi'' \rho' \iota_{z'} $. Therefore
  $ \psi' = \psi'' \rho' $ by the universal property of
  coproducts.

  Furthermore, $ \psi \rho \iota_z $,
  $ \psi \rho \iota_z $, and $ c $ form a cocone
  under the span $ x \gets y \to z $ on the top
  face of Diagram \ref{eq:qmmp-1}. then
  $ \psi \rho \iota_x = \psi' \gamma \iota_x =
  \psi'' \rho' \gamma \iota_x = \psi'' \psi' \rho
  \iota_x $ and
  $ \psi \rho \iota_z = \psi' \gamma \iota_z =
  \psi'' \rho' \gamma \iota_z = \psi'' \gamma'
  \rho \iota_z $ meaning that both $ \psi $ and
  $ \psi'' \psi' $ satisfy the canonical map
  $ x+_yz \to d $. Hence $ \psi = \psi'' \psi' $.

  The universality of $ \psi'' $ with respect to
  Diagram \ref{eq:qmmp-3} follows from the
  universality of $ \gamma'' $ with respect to
  $ x'+_{y'}z' $.
\end{proof}

\begin{proposition} \label{thm:comp-preserve-monic}
  Horizontal and vertical composition preserve rewrite rules
  of structured cospans.
\end{proposition}

\begin{proof}
  For the horizontal composition of
  rewrites \input{assets/compPreserveMonic1.tex}, the arrows 
  $ w +_{Le} x \to u+_{Lb} v $ and
  $ w +_{Le} x \to y +_{Lh} z $ are monic. This is seen by applying
  Lemma \ref{thm:quotient-map-monic-pushout} to the diagrams
  \input{assets/compPreserveMonic2.tex}
  
  The result for vertical composition holds because pullback
  preserves monomorphisms.

  % \input{assets/compPreserveMonic3.tex} is the diagram eq
  % for vert comp.
\end{proof}

With horizontal and vertical composition in hand, we
construct the double category $ _L\RRRewrite $.
Actually, we delay discussing the interchange law until
Section \ref{sec:interchange-law} because it is difficult
enough to warrant its own section.

\begin{proposition}
\label{thm:rewrite-double-cat}
  Let
  \[
    \adjunction{\X}{L}{R}{\A}
  \]
  be a adjunction with $ L $ preserving pullbacks.  There is
  a double category $ _L\RRRewrite $ whose objects are the
  $ \A $-objects, horizontal arrows of type $ a \to b $ are
  structured cospans $ La \to x \gets Lb $, vertical arrows
  of type $ a \to b $ are isomorphism classes of spans
  $ a \gets c \to b $ in $ \A $ with invertible arrows, and
  squares are rewrites of structured cospans
  \input{assets/rewriteDoubleCat1.tex}
\end{proposition}

\begin{proof}
  This proof requires we check the axioms of a double
  category. For simplicity, we denote $_L\RRRewrite$ by
  $\RRR $ in this proof.

  The object category $\RRR_0$ is given by objects of $\A$
  and isomorphism classes of spans in $\A$ such that each
  leg is an isomorphism.  The arrow category $\RRR_1$ has as
  objects the structured cospans
  \[
    La \to x \gets La'
  \]
  and as morphisms the fine rewrites of structured cospans.
	
  The functor $U \from \RRR_0 \to \RRR_1$ acts on objects by
  mapping $a$ to the identity cospan on $La$ and on
  morphisms by mapping $La \gets Lb \to Lc$, whose legs are
  isomorphisms, to the square
  \input{assets/rewriteDoubleCat2.tex}
  
  The functor $S \from \RRR_1 \to \RRR_0$ acts on objects by
  sending $La \to x \gets La'$ to $a$ and on morphisms by
  sending a square \input{assets/rewriteDoubleCat3.tex}
  
  to the span $ La \gets Lb \to Lc $. The functor $T$ is
  defined similarly sends an object \[ La \to x \gets La' \]
  of $ \RRR_1 $ to $ a' $ a square
  \input{assets/rewriteDoubleCat4.tex} to the span
  $ La' \gets Lb' \to Lc' $.
  
  The horizontal composition functor
  \[
    \odot \from \RRR_1 \times_{\RRR_0} \RRR_1 \to
    \RRR_1
  \]
  acts on objects by composing cospans with pushouts in the
  usual way.  It acts on morphisms by
  \input{assets/rewriteDoubleCat5.tex}

  The interchange law holds
  \cite[Lem.~4.3]{CicCour_SpCspTopos}, therefore $\odot$ is
  a functor. It is straightforward to check that the
  required equations are satisfied.  The associator and
  unitors are given by natural isomorphisms that arise from
  universal properties.
\end{proof}

And now, our double category of rewrites is defined.


%% =====================================================
\section{Expressiveness of grammars}
\label{sec:gen-result-graph-rewriting}
%% =====================================================

For a rewrite rule $ \ell \gets k \to r $, there is no
constraint on the value of $ k $. Even though we interpret
it as being the suboject of $ \ell $ and $ r $ that remains
fixed through the application of the rule, it can actually
be any object of the topos in which we are working.  Such
freedom is difficult to work with, so we devise a more
restrained alternative. That is, we ask that $ k $ be
\emph{discrete}. In this section, we make the term
`discrete' precise and show that the rewriting relation of a
grammar $ (\T,P) $ is the same as the discretized variant of
$ (\T,P) $. This result generalizes a characterization of
discrete graph grammars given by Ehrig,
et.~al. \cite[Prop.~3.3]{Ehrig_GraphGram}.

Experts in topos theory may recognize `discreteness' from
the flat modality on a local topos. However, we avoid the
lengthy detour required to discuss what a `flat modality'
and a `local topos' actually are because it would not add to
our story (curious readers can find this information elsewhere
\cite[Ch.~C3.6]{Johnstone_Sketches}). The cost of avoiding
this detour is one comonad.

The definition of the `discrete comonad' is straightforward
enough, but its purpose may seem alien at first. After the
definition, we explain its role in rewriting structured
cospans.

\begin{definition}[Discrete comonad]
  \label{def:discrete-comonad}
  A comonad on a topos is called \df{discrete} if its counit
  is monic. We use $ \flat $ to denote a discrete comonad.
\end{definition}

Secretly, we have been working with a discrete comonad all
along. The adjunction $$\adjunction{\RGraph}{L}{R}{\Set}$$
induces the comonad $ LR $ on $ \RGraph $.  Applying $ LR $ to
a graph $ x $ returns the edgeless graph underlying $
x $, hence the term `discrete'. For example \input{assets/discreteComonadExample.tex} 

The counit $ \epsilon_x \from LRx \to x $ of the comonad
$ LR $ includes the underlying edgeless graph $ LRx $ into
the original graph $ x $. For example, \input{assets/includeEdgelessGraphEx.tex}

Abstractly, this inclusion is why we ask for the counit to
be monic. The property we capture with a discrete comonad
comes from the systems interpretation of the
adjunctions $$\adjunction{\X}{L}{R}{\A}$$ between
topoi. That is, $ R $ takes a system $ x $, identifies the
largest sub-system that can serve as an interface and turns
that sub-system into an interface type $ Rx $. Then $ L $
takes that interface type and turns it back into a system
$ LRx $. This process effectively strips away every part of
a system leaving only those parts that can connect to the
outside world. That means $ LRx $ is a part of $ x $ or, in
the parlance of category theory, $ LRx $ is a subobject of
$ x $.  Hence, we ask for a monic counit.

How do we plan to use discrete comonads?  We use them to
control the form of our grammars. In particular, we can \emph{discretize} any rewrite
rule $$\ell \gets k \to r$$ by replacing $ k $ with
$ \flat k $.  

\begin{definition}[Discrete grammar]
  Given a grammar $ ( \X , P ) $, define $ P_\flat $ as the set
  consisting of a rule
  \[ \ell \gets k \gets \flat k \to k \to r \]
  for each rule $ \ell \gets k \to r $ in $ P $. We call $
  ( X , P_\flat ) $ the \df{discrete grammar} underlying $
  ( \X, P ) $.
\end{definition}

Theorem \ref{thm:production-same-rewrite-relation-as-discrete} gives
a sufficient condition that allows us to swap $ ( \X,P ) $
for $ ( \X,P_\flat ) $ without consequence. The proof of this theorem borrows from lattice theory, so let us digress from rewriting to fill in the requisit background.

\begin{definition}[Lattice]
  A lattice is a poset $ ( S, \leq ) $ equipped with all
  finite joins $ \bigvee $ and all finite meets
  $ \bigwedge $. It follows that there is a minimal 0 element
  and maximal element 1, realized as the empty meet and join,
  respectively.
\end{definition}

Joins and meets are also known as suprema and infima. We are
using the definition of a lattice common in the category
theory literature. This leaves out objects that some
mathematicians might consider lattices. Below we give one
counter-example and several examples of lattices, the last
one being the most relevant.

\begin{example}[Integer Lattice]
  The integers with the usual ordering $ \leq $ do not form
  a lattice because there is no minimal or maximal element.
\end{example}

\begin{example}[Lattice of power sets]
  For any set $ S $, its powerset $ \mathcal{P}S $ is a
  poset via subset inclusion. The powerset becomes a lattice
  by taking join to be union $ a \vee b \bydef a \cup b $,
  and meet to be intersection $ a \wedge b \bydef a \cap b
  $. In general, union and intersection are defined over
  arbitrary sets, thus realizing arbitrary joins
  $ \bigvee a_\alpha $ and arbitrary meets
  $ \bigwedge a_\alpha $. 
\end{example}

Those few examples provide intuition about lattices, but the
next example is the most important lattice for us. It is the
mechanism by which the power set is generalized into topos
theory. It is called the subobject lattice.

\begin{example}[Subobject lattice]
  Let $ \T $ be a topos and $ t $ be an object. There is a
  lattice $ \Sub (t) $ called the subobject lattice of
  $ t $.  The elements of $ \Sub (t) $, called
  subobjects, are isomorphism classes of monomorphisms
  into $ t $. Here, two monomorphisms $ f,g $ into $ t $ are
  isomorphic if there is a commuting diagram \include{assets/isoMonics.tex}
  
  The order on $ \Sub (t) $ is given by $ f \leq g $ if
  $ f $ factors through $ g $, meaning there is an arrow
  $ h \from a \to b $ such that $ f = gh $. Note that $ h $
  is necessarily monic. The meet operation in $ \Sub (t) $
  is given by pullback \input{assets/meetPullback.tex} and
  join is given by pushout over the meet
  \input{assets/meetPushout.tex}
\end{example}

Subobject lattices provide a way to compare the expressivity of a grammar to its underlying discrete grammar.
To do
this, we require a subobject lattice with arbitrary meets.  The
powerset lattice mentioned above has this property, but
when does a subobject lattice have this property?  Here are
several sufficient conditions, starting with a well-known
result from order theory.

\begin{proposition} \label{thm:lattice-alljoins-allmeets}
  Any lattice that has all joins also has all meets.
\end{proposition}

\begin{proof}
  Consider a subset $ S $ of a lattice. Define the meet of $
  S $ to be the join of the set of all lower bounds of $ S $.
\end{proof}

\begin{proposition} \label{thm:subob-arbitrary-meets}
  Fix an object $t$ of a topos $ \T $.  The subobject
  lattice $ \Sub (t) $ has arbitrary meets when the over-category 
	$ T \downarrow t $ has all products.
\end{proposition}

\begin{proof}
  Because $ T \downarrow t $ is a topos, it has
  equalizers. Thus giving it all products ensures the
  existence of all limits, hence meets. 
\end{proof}

\begin{corollary}
  Fix an object $t$ of a topos $ \T $.  The subobject
  lattice $ \Sub (t) $ has arbitrary meets when the over
  category $ T \downarrow t $ has all coproducts.
\end{corollary}

\begin{proof}
  Combine Propositions \ref{thm:lattice-alljoins-allmeets}
  and \ref{thm:subob-arbitrary-meets}.
\end{proof}

The case where $\T$ is a presheave category is especially pertinent to us because, often, a system can be encoded as a presheaf. Labelled graphs offer a large cache of examples.

At last, we combine the discrete comonad, the discrete
grammar, and the complete subobject lattice into a result on
the expressiveness on discrete grammars.

\begin{theorem}
  \label{thm:production-same-rewrite-relation-as-discrete}  
  Let $ \T $ be a topos and $ \flat \from \T \to \T $ be a
  discrete comonad.  Let $ ( \T , P ) $ be a grammar such
  that for every rule $ \ell \gets k \to r $ in $ P $, the
  subobject lattice $ \Sub (k) $ has all meets. Then the
  rewriting relation for $ ( \T , P ) $ equals the
  rewriting relation for the underlying discrete grammar
  $ ( \T,P_\flat ) $.
\end{theorem}

\begin{proof}
  Suppose that $ ( \T,P ) $ induces $ \dderiv{g}{h} $. That
  means there exists a rule $ \spn{\ell}{k}{r} $ in $ P $
  and a derivation \input{assets/expressivityProof1.tex}
  
  we can achieve that same derivation using rules in
  $ P_\flat $. This requires we build a pushout complement
  $ w $ of the diagram \input{assets/expressivityProof2.tex}

  Define
  \[ w \coloneqq \bigwedge \{ z \colon z \vee k = d \} \vee
    \flat k,\] This comes with inclusions $ \flat k \to w $
  and $ w \to d $. This $ w $ exists because $ \Sub (k) $
  has all meets.  Note that $ w \vee k = d $ and
  $ w \wedge k = \flat k $ which means that
  \input{assets/expressivityProof3.tex} is a pushout. It
  follows that there is a derivation
  \input{assets/expressivityProof4.tex} with respect to
  $ P_\flat $ because, the top row is a rule in $ P_\flat $.
  Therefore, $ \dderiv{g}{h} $ via $ P $ in Diagram
  \eqref{eq:prod-rewrite-1} implies that $ \deriv{g}{h} $
  via $ P_\flat $ as shown in Diagram
  \eqref{eq:prod-rewrite-2}.

  For the other direction, suppose $ \dderiv{g}{h} $ via
  $ P_\flat $, giving a derivation
  \input{assets/expressivityProof5.tex}

  By construction of $ P_\flat $, the rule
  $ \spn{\ell}{\flat k}{r} $ in $ P_\flat $ was induced from
  a rule $$\ell \xgets{\tau} k \to r$$ in $ P $, meaning
  that the map $ \flat k \to \ell $ factors through
  $ \tau $. Next, define $ d' $ to be the pushout of the
  diagram \input{assets/expressivityProof6.tex}

  By invoking the universal property of this pushout with
  the maps
  \[
    \psi \from d \to g \quad \text{and} \quad m \tau \from k
    \to \ell \to g,
  \]
  we get a canonical map $ d' \to g $ that we can fit into a
  commuting diagram \input{assets/expressivityProof7.tex}
  whose back faces are pushouts. Using a standard diagram
  chasing argument, we can show that the front face is also
  a pushout.  Similarly, the square
  \input{assets/expressivityProof8.tex} is a pushout.  Sticking
  these two pushouts together
  \input{assets/expressivityProof9.tex} shows that
  $ \dderiv{g}{h} $ arises from $ P $.

  Because the relation $ \dderiv{}{} $ is the same for $ P $
  and $ P_\flat $, it follows that $ \deriv{}{} $ is also
  the same as claimed.
\end{proof}




%% =======================================
%% =======================================

\section{Characterizing the rewrite relation for closed
  systems}
\label{sec:charRewrRelat}

Here, we apply the theory of rewriting structured cospans to
classifying the rewrite relation for closed systems. We start
by formalizing closed systems as structured cospans with an
empty interface $ L0 \to x \gets L0 $. In other words,
closed systems are particular horizontal 1-arrows in the
double category $ _L \RRRewrite $.  To decompose a closed
system $$L0 \to x \gets L0$$ is to write an arrow as a
composite of arrows
\[
  L0 \to x_1 \gets La_1 \to x_2 \gets La_2 \to
  \dotsm \gets La_{n-1} \to x_n \gets L0
\]
We use such decompositions to prove our main result which
states that two structured cospans
\[
  L0 \to x \gets L0
  \quad \text{and} \quad
  L0 \to x' \gets L0
\]
are equivalent precisely when there is a square between
them.  We interpret this result in three ways.

\begin{enumerate}
\item It shows that the rewriting relation for a closed system
  is functorial and is characterized using squares in a double
  category.
\item A closed system decomposes into open systems and
  simplifying each open system simplifies the composite
  closed system.  
\item Open systems provide a local perspective on closed
  systems via this decomposition.
\end{enumerate}

To decompose closed systems into open systems, we need a
topos of closed systems $ \X $ equipped with a grammar
$ ( \X , P ) $. The closed systems need interfaces, meaning
we need to introduce an adjunction
\[
  \adjunction{\X}{L}{R}{\A}
\]
where $ L $ preserves pullbacks and has a monic counit. At
this point, the material from the previous section
returns. This adjunction gives a discrete comonad $ \flat
\bydef LR $ from which we form the discrete
grammar $ ( \X, P_\flat ) $. Now define the structured cospan
grammar $ ( _L \StrCsp , \hat{P_\flat} ) $ where $
\hat{P_\flat} $ contains the rule \input{assets/decompSquare}
for each rule $ \spn{\ell}{LRk}{r} $ of $ P_{\flat} $. We
use $ ( _L \StrCsp , \hat{P_\flat} ) $ to prove our main
theorem.

Before stating the theorem, we note that this theorem
generalizes work by Gadducci and Heckel
\cite{Gadd_IndGraphTrans} whose domain of
inquiry was graph rewriting. The arc of our
proof follows theirs.


\begin{theorem} \label{thm:inductive-rewriting}
  Fix an adjunction $ (L \dashv R) \from \X \lrto \A $ with
  monic counit. Let $ ( \X , P ) $ be a grammar such that
  for every $ \X $-object $ x $ in the apex of a production
  of $ P $, the lattice $ \Sub (x) $ has all meets. Given
  $ g $, $ h \in \X $, then $ \deriv{g}{h} $ in the
  rewriting relation for a grammar $ ( \X , P ) $ if and
  only if there is a square
  \input{assets/inductiveRewriting1.tex} 
  in the double category $ \Lang ( _{L}\StrCsp , \hat{P_\flat} ) $.
\end{theorem}

\begin{proof}
  We show sufficiency by inducting on the length of the
  derivation. If $ \deriv{g}{h} $ in a single step, meaning
  that there is a diagram
  \input{assets/inductiveRewriting2.tex}
  then the desired square is the horizontal composition of
  \input{assets/inductiveRewriting3.tex}
  
  The left square is a generator and the right square is the
  identity on the horizontal arrow $ \csp{LRk}{d}{L0}
  $. The square for a derivation
  $ \dderiv{\deriv{g}{h}}{j} $ is the vertical composition
  of
  \input{assets/inductiveRewriting4.tex}
  
  The top square is from $ \deriv{g}{h} $ and the second
  from $ \dderiv{h}{j} $.

  Conversely, proceed by structural induction on the
  generating squares of
  $ \Lang ( _{L}\StrCsp , \hat{P_\flat} ) $.  It suffices to
  show that the rewrite relation is preserved by vertical
  and horizontal composition by generating squares.  Suppose
  we have a square
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ w $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ x $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ y $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  % 
  corresponding to a derivation $ \deriv{w}{y} $. Composing
  this vertically with a generating square, which must have
  form
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ y $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ L 0 $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ z $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  %
  corresponding to a production $ \spn{y}{L0}{z} $ gives
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ w $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ L 0 $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ z $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  %
  which corresponds to a derivation
  $ \dderiv{\deriv{w}{y}}{z} $.  Composing horizontally with
  a generating square
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ \ell $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ LRk $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ r $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  % 
  corresponding with a production $ \spn{\ell}{LRk}{r} $
  results in the square
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ w + \ell $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ x + LRk $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ y + r $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  %
  But $ \deriv{w+\ell}{y+r} $ as seen in Lemma
  \ref{thm:rewrite-rel-is-additive}. 
\end{proof}

With this result, we have completely described the rewrite
relation for a grammar $ ( \X , P ) $ with squares in
$ \Lang ( _{L}\StrCsp, \hat{P_\flat} ) $ framed by the
initial object of $ \X $.  These squares are rewrites of a
closed system in the sense that the interface is empty.  We
can instead begin with a closed system $ x $ in $ \X $ as
represented by a horizontal arrow $ \csp{L0}{x}{L0} $ in
$ \Lang ( _{L}\StrCsp , \hat{P_\flat} ) $ and decompose it
into a composite of sub-systems, that is a sequence of
composable horizontal arrows

\begin{center}\begin{tikzpicture}
  \node (L0) at (0,0) {$ L0 $};
  \node (x1) at (1,1) {$ x_1 $};
  \node (La1) at (2,0) {$ La_1 $};
  \node (x2) at (3,1) {$ x_2 $};
  \node (La2) at (4,0) {$ La_2 $};
  \node () at (5,0) {$ \dotsm $};
  \node (Lan1) at (6,0) {$ La_{n-1} $};
  \node (xn) at (7,1) {$ x_n $};
  \node (L0') at (8,0) {$ L0 $};
  % 
  \draw [cd] 
    (L0) edge[] (x1)
    (La1) edge[] (x1)
    (La1) edge[] (x2)
    (La2) edge[] (x2)
    (Lan1) edge[] (xn)
    (L0') edge[] (xn);
\end{tikzpicture}\end{center}

Rewriting can be performed on each of these sub-systems
%
\begin{center}\begin{tikzpicture}
\begin{scope}[shift={(0,6)}]
  \node (1) at (0,4) {$ L0 $};
  \node (2) at (2,4) {$ x_1 $};
  \node (3) at (4,4) {$ La_1 $};
  \node (4) at (0,2) {$ L0 $};
  \node (5) at (2,2) {$ x'_1 $};
  \node (6) at (4,2) {$ La'_1 $};
  \node (7) at (0,0) {$ L0 $};
  \node (8) at (2,0) {$ x''_1 $};
  \node (9) at (4,0) {$ La''_1 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (1);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong  $}} (3);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong $}} (9);
\end{scope}
% 
\begin{scope}[shift={(6,6)}]
  \node (1) at (0,4) {$ La_{n-1} $};
  \node (2) at (2,4) {$ x_n $};
  \node (3) at (4,4) {$ L0 $};
  \node (4) at (0,2) {$ La_{n-1} $};
  \node (5) at (2,2) {$ x'_n $};
  \node (6) at (4,2) {$ L0 $};
  \node (7) at (0,0) {$ La_{n-1} $};
  \node (8) at (2,0) {$ x''_n $};
  \node (9) at (4,0) {$ L0 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (1);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong  $}} (3);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong $}} (9);
\end{scope}
% 
\begin{scope}
  \node (1) at (0,4) {$ L0 $};
  \node (2) at (2,4) {$ y_1 $};
  \node (3) at (4,4) {$ La_1 $};
  \node (4) at (0,2) {$ L0 $};
  \node (5) at (2,2) {$ y'_1 $};
  \node (6) at (4,2) {$ La_1 $};
  \node (7) at (0,0) {$ L0 $};
  \node (8) at (2,0) {$ y''_1 $};
  \node (9) at (4,0) {$ La_1 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node[left]{$\cong$} (1);
  \draw [cd] (4) to node[left]{$\cong$} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node[right]{$\cong$} (3);
  \draw [cd] (6) to node[right]{$\cong$} (9);
\end{scope}
% 
\begin{scope}[shift={(6,0)}]
  \node (1) at (0,4) {$ La_{n-1} $};
  \node (2) at (2,4) {$ y_n $};
  \node (3) at (4,4) {$ L0 $};
  \node (4) at (0,2) {$ La_{n-1} $};
  \node (5) at (2,2) {$ y'_n $};
  \node (6) at (4,2) {$ L0 $};
  \node (7) at (0,0) {$ La_{n-1} $};
  \node (8) at (2,0) {$y''_n $};
  \node (9) at (4,0) {$ L0 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node [left] {$\cong$} (1);
  \draw [cd] (4) to node [left] {$\cong$} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node [right] {$\cong$} (3);
  \draw [cd] (6) to node [right] {$\cong$} (9);
\end{scope}
% 
\node () at (5,2) {$ \dotsm $};
\node () at (2,5) {$ \vdots $};
\node () at (5,8) {$ \dotsm $};
\node () at (8,5) {$ \vdots $};
\end{tikzpicture}\end{center}
%
The composite of these squares is a rewriting of the
original system.

\bibliographystyle{plain}
\bibliography{assets/biblio}



\end{document}

