\documentclass{amsart}
% \linespread{2}
\input{assets/preamble.tex}

\begin{document}
\input{assets/frontMatter.tex}

%% ===================================
%% Introduction
%% ===================================
\section{Introduction}
\label{sec:Intro}


%% ===================================
%% Rewriting in Topoi
%% ===================================
\section{Rewriting in topoi}
\label{sec:RewriteTopoi}

This section serves two purposes, each of which has a
devoted subsection.  The first is to briefly sketch the
basics of double pushout rewriting.  Everything here is
standard material in the double pushout rewriting
literature, and in particular is outlined in Lack and
Sobocinski's work on adhesive categories
\cite{LackSobo_Adhesive}.  We restrict our attention to
rewriting in topoi, which is a special case of rewriting in
adhesive categories \cite{LackSobo_TopsIsAdh}, because that
fits the level of generality in which we work.

In the second subsection, we generalize a result on the
expressivity of grammars.  In the paper that introduced
graph rewriting \cite{Ehrig_GraphGram}, the authors classify
graph grammars along certain characteristics. One class of
grammars consists of those graph grammars, that is a set of
graph rewrite rules $ \{ \ell \to k \gets r \} $, with no
restrictions placed on the graphs $ \ell $, $ k $, $ r
$. Another class of grammars consists of those such that the
center graph $ k $ is discrete (has no edges).  Erhig,
et.~al. showed that these two classes generate the same
language \cite[Prop.~3.3]{Ehrig_GraphGram}. In Section
\ref{sec:gen-result-graph-rewriting}, we generalize this
from a result that holds in the category $ \Graph $ to
holding in an arbitrary topos.  

%% =========================================
\section{Quickly sketching the basics}
\label{sec:SketchBasics}
%% =========================================

\Daniel{something more impactful here}

The topic of double pushout rewriting is well represented in
the literature. Here, we cover the basics and set our
notation and convention. Experts can skip to the next
section. Novices have many suitable choices to supplement
this review, though we suggest Lack and Sobocinski's
axiomatization of rewriting in adhesive categories
\cite{LackSobo_Adhesive}.

Rewriting starts with the notion of a \df{rewrite rule}, or
simply \df{rule}. In its most general form, a rule is a span
\[
  \ell \gets k \to r
\]
in a topos. For us, the arrows are of the span are always
monic and, whenever possible, unnamed.

The conceit of a rule is that $ r $ replaces $ \ell $ while
$ k $ identifies a subsystem of $ \ell $ that remains
fixed. For example, suppose we were modeling some system
using graphs where self-loops are negligable. For example,
consider a model of the internet as a graph with websites
for nodes and links for edges. If we wished to ignore links
from a websites to itself, we can introduce a rule
that replaces a loop on a node with that node
\input{assets/squashLoopRule.tex}

To \emph{apply} a rule $ \ell \gets k \to r $ to an object
$ \ell' $, we require an arrow $ \ell \to \ell' $ such that
there exists a \df{pushout complement}, an object $ d $
fitting into a pushout diagram \input{assets/pushoutComplement} 
A pushout complement need not exist, but when it does and
the map $ k \to \ell $ is monic, then it is unique up to
isomorphism \cite[Lem.~15]{LackSobo_Adhesive}.

Each application of a rule begets a new rule.

\begin{definition}[Derived rule] \label{def:derived-rule}
  Applying a rule $ \ell \gets k \to r $ to an object $ g $
  induces a \df{derived rule} $ \ell' \gets k' \to r' $ that
  fits into the bottom row of the double pushout diagram
  \input{assets/derivedRule.tex}
\end{definition}

The arrows of derived rule are also monic because pushouts
in topoi preserve monics
\cite[Lem.~12]{lack-sobo_adhesive-cats}. Interpret this
diagram as follows: the map $ \ell \to \ell' $ selects a
copy of $ \ell $ inside $ \ell' $ and that copy is replaced
by $ r $ resulting in the new object $ r' $. 

To illustrate, let us return to the internet modeled using
graphs and negligable self-loops.  Then we can
apply Rule \eqref{eq:squash-loop-rule} to any node with a
loop. This application is captured with the double pushout
diagram \input{assets/squashLoopRuleApplied.tex}

The map $ m $ selects the self-loop and corresponding node
in the bottom left graph. A pushout complement exists,
meaning that the rule can be applied and so the loop is
removed. The result is the bottom right graph.  The reader
can check that the two squares are pushouts.

Specialists is a particular sort of system spend time
understanding the its rewrite rules. Resistor circuits have
parallel, series, and star rules. Other systems have their
own versions. Therefore, we consider a system equipped with
a set of rules. 

\begin{definition}[Grammar] \label{def:grammar} A topos
  $ \T $ together with a finite set $ P $ of rules
  $ \{ \spn{\ell_j}{k_j}{r_j} \} $ in $ \T $ is a
  \df{grammar}. A morphisms of grammars
  $ ( \cat{S} , P ) \to ( \T , Q ) $ is a pullback and pushout
  preserving functor $ F \from \cat{S} \to \T $ such that for
  each rule $ \xspn{\ell}{f}{k}{g}{r} $ in $ P $, the rule
  $ \xspn{F\ell}{Ff}{Fk}{Fg}{Fr} $ is in $ Q $. Together
  these form a category $ \Gram $.
\end{definition}

Like a seed, from a grammar grows something entirely new
called the \emph{language}. The language contains all necessary
information about the syntax of a system, so naturally, it
is the thing to study. The potential complexity of a
language makes this a difficult task, so we instead turn to
a more accessible proxy called the \emph{rewrite
  relation}. This relation captures the relationship between
the many sytactical componenets of a language.  

Constructing the rewrite relation requires several steps.  A
grammar $ ( \T , P ) $ induces a relation
$ \dderiv{}{} $ on the objects of $ \T $ defined by
$ \dderiv{g}{h} $ whenever there exists a rule
$ \spn{g}{d}{h} $ derived from a production in $ P $. For
instance, the above double pushout diagram would relate
\input{assets/dpoRelates.tex}

But $ \dderiv{}{} $ is too small to capture the full
behavior of the language.  For one, it is not true in
general that $ \dderiv{g}{g} $ holds. Also, $ \dderiv{}{} $
does not capture multi-step rewrites. That is, there may be
derived rules witnessing $ \dderiv{g}{g'} $ and
$ \dderiv{g'}{g''} $ but not a derived rule witnessing
$ \dderiv{g}{g''} $. We want to relate a pair of objects if
one can be rewritten into another using a finite sequence of
rules that are either in $ P $ or derived from a rule in
$ P $. Therefore, we define the \df{rewrite relation} to be
the reflexive and transitive closure of $ \dderiv{}{} $

After we introduce a grammar for structured cospans in Section
\ref{sec:}, we show that constructing it is functorial.

%% =====================================================
\section{Expressiveness of grammars}
\label{sec:gen-result-graph-rewriting}
%% =====================================================

For a rewrite rule $ \ell \gets k \to r $, there is no
constraint on the value of $ k $. Even though we interpret
it as being the suboject of $ \ell $ and $ r $ that remains
fixed through the application of the rule, it can actually
be any object of the topos in which we are working.  Such
freedom is difficult to work with, so we devise a more
restrained alternative. That is, we ask that $ k $ be
\emph{discrete}. In this section, we make the term
`discrete' precise and show that the rewriting relation of a
grammar $ (\T,P) $ is the same as the discretized variant of
$ (\T,P) $. This result generalizes a characterization of
discrete graph grammars given by Ehrig,
et.~al. \cite[Prop.~3.3]{Ehrig_GraphGram}.

Experts in topos theory may recognize `discreteness' from
the flat modality on a local topos. However, we avoid the
lengthy detour required to discuss what a `flat modality'
and a `local topos' actually are because it would not add to
our story (curious readers can find this information elsewhere
\cite[Ch.~C3.6]{Johnstone_Sketches}). The cost of avoiding
this detour is one comonad.

The definition of the `discrete comonad' is straightforward
enough, but its purpose may seem alien at first. After the
definition, we explain its role in rewriting structured
cospans.

\begin{definition}[Discrete comonad]
  \label{def:discrete-comonad}
  A comonad on a topos is called \df{discrete} if its counit
  is monic. We use $ \flat $ to denote a discrete comonad.
\end{definition}

Secretly, we have been working with a discrete comonad all
along. The adjunction $$\adjunction{\RGraph}{L}{R}{\Set}$$
induces the comonad $ LR $ on $ \RGraph $.  Applying $ LR $ to
a graph $ x $ returns the edgeless graph underlying $
x $, hence the term `discrete'. For example \input{assets/discreteComonadExample.tex} 

The counit $ \epsilon_x \from LRx \to x $ of the comonad
$ LR $ includes the underlying edgeless graph $ LRx $ into
the original graph $ x $. For example, \input{includeEdgelessGraphEx.tex}

Abstractly, this inclusion is why we ask for the counit to
be monic. The property we capture with a discrete comonad
comes from the systems interpretation of the
adjunctions $$\adjunction{\X}{L}{R}{\A}$$ between
topoi. That is, $ R $ takes a system $ x $, identifies the
largest sub-system that can serve as an interface and turns
that sub-system into an interface type $ Rx $. Then $ L $
takes that interface type and turns it back into a system
$ LRx $. This process effectively strips away every part of
a system leaving only those parts that can connect to the
outside world. That means $ LRx $ is a part of $ x $ or, in
the parlance of category theory, $ LRx $ is a subobject of
$ x $.  Hence, we ask for a monic counit.

How do we plan to use discrete comonads?  We use them to
control the form of our grammars. In particular, we can \emph{discretize} any rewrite
rule $$\ell \gets k \to r$$ by replacing $ k $ with
$ \flat k $.  

\begin{definition}[Discrete grammar]
  Given a grammar $ ( \X , P ) $, define $ P_\flat $ as the set
  consisting of a rule
  \[ \ell \gets k \gets \flat k \to k \to r \]
  for each rule $ \ell \gets k \to r $ in $ P $. We call $
  ( X , P_\flat ) $ the \df{discrete grammar} underlying $
  ( \X, P ) $.
\end{definition}

Theorem \ref{thm:production-same-rewrite-relation-as-discrete} gives
a sufficient condition that allows us to swap $ ( \X,P ) $
for $ ( \X,P_\flat ) $ without consequence. The proof of this theorem borrows from lattice theory, so let us digress from rewriting to fill in the requisit background.

\begin{definition}[Lattice]
  A lattice is a poset $ ( S, \leq ) $ equipped with all
  finite joins $ \bigvee $ and all finite meets
  $ \bigwedge $. It follows that there is a minimal 0 element
  and maximal element 1, realized as the empty meet and join,
  respectively.
\end{definition}

Joins and meets are also known as suprema and infima. We are
using the definition of a lattice common in the category
theory literature. This leaves out objects that some
mathematicians might consider lattices. Below we give one
counter-example and several examples of lattices, the last
one being the most relevant.

\begin{example}[Integer Lattice]
  The integers with the usual ordering $ \leq $ do not form
  a lattice because there is no minimal or maximal element.
\end{example}

\begin{example}[Lattice of power sets]
  For any set $ S $, its powerset $ \mathcal{P}S $ is a
  poset via subset inclusion. The powerset becomes a lattice
  by taking join to be union $ a \vee b \bydef a \cup b $,
  and meet to be intersection $ a \wedge b \bydef a \cap b
  $. In general, union and intersection are defined over
  arbitrary sets, thus realizing arbitrary joins
  $ \bigvee a_\alpha $ and arbitrary meets
  $ \bigwedge a_\alpha $. 
\end{example}

Those few examples provide intuition about lattices, but the
next example is the most important lattice for us. It is the
mechanism by which the power set is generalized into topos
theory. It is called the subobject lattice.

\begin{example}[Subobject lattice]
  Let $ \T $ be a topos and $ t $ be an object. There is a
  lattice $ \Sub (t) $ called the subobject lattice of
  $ t $.  The elements of $ \Sub (t) $, called
  subobjects, are isomorphism classes of monomorphisms
  into $ t $. Here, two monomorphisms $ f,g $ into $ t $ are
  isomorphic if there is a commuting diagram \include{assets/isoMonics.tex}
  
  The order on $ \Sub (t) $ is given by $ f \leq g $ if
  $ f $ factors through $ g $, meaning there is an arrow
  $ h \from a \to b $ such that $ f = gh $. Note that $ h $
  is necessarily monic. The meet operation in $ \Sub (t) $
  is given by pullback \include{assets/meetPullback.tex} and
  join is given by pushout over the meet
  \input{assets/meetPushout.tex}
\end{example}

Subobject lattices provide a way to compare the expressivity of a grammar to its underlying discrete grammar.
To do
this, we require a subobject lattice with arbitrary meets.  The
powerset lattice mentioned above has this property, but
when does a subobject lattice have this property?  Here are
several sufficient conditions, starting with a well-known
result from order theory.

\begin{proposition} \label{thm:lattice-alljoins-allmeets}
  Any lattice that has all joins also has all meets.
\end{proposition}

\begin{proof}
  Consider a subset $ S $ of a lattice. Define the meet of $
  S $ to be the join of the set of all lower bounds of $ S $.
\end{proof}

\begin{proposition} \label{thm:subob-arbitrary-meets}
  Fix an object $t$ of a topos $ \T $.  The subobject
  lattice $ \Sub (t) $ has arbitrary meets when the over-category 
	$ T \downarrow t $ has all products.
\end{proposition}

\begin{proof}
  Because $ T \downarrow t $ is a topos, it has
  equalizers. Thus giving it all products ensures the
  existence of all limits, hence meets. 
\end{proof}

\begin{corollary}
  Fix an object $t$ of a topos $ \T $.  The subobject
  lattice $ \Sub (t) $ has arbitrary meets when the over
  category $ T \downarrow t $ has all coproducts.
\end{corollary}

\begin{proof}
  Combine Propositions \ref{thm:lattice-alljoins-allmeets}
  and \ref{thm:subob-arbitrary-meets}.
\end{proof}

The case where $\T$ is a presheave category is especially pertinent to us because, often, a system can be encoded as a presheaf. Labelled graphs offer a large cache of examples.

At last, we combine the discrete comonad, the discrete
grammar, and the complete subobject lattice into a result on
the expressiveness on discrete grammars.

\begin{theorem}
  \label{thm:production-same-rewrite-relation-as-discrete}  
  Let $ \T $ be a topos and $ \flat \from \T \to \T $ be a
  discrete comonad.  Let $ ( \T , P ) $ be a grammar such
  that for every rule $ \ell \gets k \to r $ in $ P $, the
  subobject lattice $ \Sub (k) $ has all meets. Then the
  rewriting relation for $ ( \T , P ) $ equals the
  rewriting relation for the underlying discrete grammar
  $ ( \T,P_\flat ) $.
\end{theorem}

\begin{proof}
  Suppose that $ ( \T,P ) $ induces $ \dderiv{g}{h} $. That
  means there exists a rule $ \spn{\ell}{k}{r} $ in $ P $
  and a derivation \input{assets/expressivityProof1.tex}
  
  we can achieve that same derivation using rules in
  $ P_\flat $. This requires we build a pushout complement
  $ w $ of the diagram \input{assets/expressivityProof2.tex}

  Define
  \[ w \coloneqq \bigwedge \{ z \colon z \vee k = d \} \vee
    \flat k,\] This comes with inclusions $ \flat k \to w $
  and $ w \to d $. This $ w $ exists because $ \Sub (k) $
  has all meets.  Note that $ w \vee k = d $ and
  $ w \wedge k = \flat k $ which means that
  \input{assets/expressivityProof3.tex} is a pushout. It
  follows that there is a derivation
  \input{assets/expressivityProof4.tex} with respect to
  $ P_\flat $ because, the top row is a rule in $ P_\flat $.
  Therefore, $ \dderiv{g}{h} $ via $ P $ in Diagram
  \eqref{eq:prod-rewrite-1} implies that $ \deriv{g}{h} $
  via $ P_\flat $ as shown in Diagram
  \eqref{eq:prod-rewrite-2}.

  For the other direction, suppose $ \dderiv{g}{h} $ via
  $ P_\flat $, giving a derivation
  \input{assets/expressivityProof5.tex}

  By construction of $ P_\flat $, the rule
  $ \spn{\ell}{\flat k}{r} $ in $ P_\flat $ was induced from
  a rule $$\ell \xgets{\tau} k \to r$$ in $ P $, meaning
  that the map $ \flat k \to \ell $ factors through
  $ \tau $. Next, define $ d' $ to be the pushout of the
  diagram \input{assets/expressivityProof6.tex}

  By invoking the universal property of this pushout with
  the maps
  \[
    \psi \from d \to g \quad \text{and} \quad m \tau \from k
    \to \ell \to g,
  \]
  we get a canonical map $ d' \to g $ that we can fit into a
  commuting diagram \input{assets/expressivityProof7.tex}
  whose back faces are pushouts. Using a standard diagram
  chasing argument, we can show that the front face is also
  a pushout.  Similarly, the square
  \input{expressivityProof8.tex} is a pushout.  Sticking
  these two pushouts together
  \input{assets/expressivityProof9.tex} shows that
  $ \dderiv{g}{h} $ arises from $ P $.

  Because the relation $ \dderiv{}{} $ is the same for $ P $
  and $ P_\flat $, it follows that $ \deriv{}{} $ is also
  the same as claimed.
\end{proof}







%% ===================================
%% The Structure of Structured Cospans
%% ===================================
\section{The Structure of Structured Cospans}
\label{sec:StructureOfStrCsp}

This paper fits into a larger program in formal systems
theory. Structured cospans, introduced by Baez and Courser
\cite{bc_strCsp}, are a syntax for open systems. The
overarching goal of this paper is to introduce rewriting to
structured cospans so that we can introduce grammars so that
the syntax whatever particular semantics we may use for a
chosen open system.  In order to introduce rewriting,
however, we need to be sure that the category of structured
cospans and their morphisms $ _L\StrCsp $ supports a
rewriting theory which we show in the Section
\ref{sec:StructureOfStrCsp} by showing that $ _L\StrCsp $ is
a topos.

In the other part of this section, we organize structured
cospans and their rewrites into a double category.  This
structure is then used in the final section where we
characterize a language of a grammar of structured cospans.

%% ===========================================
\section{Structured cospans form a topos}
\label{sec:StructureOfStrCsp}
%% ===========================================

Having discussed rewriting in a topos, in order to introduce the rewriting of structured cospans, we better ensure that they form a topos. Indeed, we do this after recalling their definition. 

Baez and Courser introduced structured cospans
\cite{bc_strCsp} to serve as a syntax for open systems. We use the term `system' broadly and avoid giving a precise definition.  By `open', we mean that compatible systems can be connected to form a larger system.  For example, a vacuum cleaner can connected to the electrical grid via an electrical socket. Or, a pulley system can connect to a mechanical motor.  

In order to form a topos out of structured cospans, we require stronger conditions than assumed by Baez and Courser.

%% define structured cospans
\begin{definition}
  Fix an adjunction $$\adjunction{\X}{L}{R}{\A}$$ between
  (elementary) topoi with $ L $ preserving finite
  limits. An \df{$ L $-structured
    cospan}, or simply \df{structured cospan}, is any cospan
  in $ \X $ of the form $ La \to x \gets Lb $.    
\end{definition}

How does the structured cospan syntax map onto an open system? The apex $x$ of the cospan
represents the system itself.  The legs of the cospan,
$ La \to x $ and $ Lb \to x $, select the inputs $ La $ and
outputs $ Lb $ of $ x $. These legs endow structured cospans with the ability to connect together. Given $ La \to x \gets Lb $ and
$ Lb \to y \gets Lc $, we form the \emph{composite}
structured cospan $ La \to x+_{Lb}y \gets Lc $. Interpret the pushout
$ x+_{Lb}y $ as an object obtained by glueing $ x $ to $ y $ along
their common interface $ Lb $. The reason we call $La \gets x+_{Lb}y \to Lc$ the `composite' is because a natural way to emphasize this connectability is by defining a category in which structured cospans are the arrows.

%% define category w str cospans as arrows
\begin{definition}
  Given an adjunction $$\adjunction{\X}{L}{R}{\A}$$ between
  (elementary) topoi with $ L $ preserving finite limits,
  denote by $ _L \Csp $ the category whose objects are those
  of $ \A $ and arrows from $ a $ to $ b $ are structured
  cospans $ La \to x \gets Lb $.  
\end{definition}

Of course, $ _L \Csp $ does not require the full strength of
those conditions to form a category---Baez and Courser do
not ask this much---but we choose to work under assumptions
that are sufficiently strong to support rewriting and
familiar and succint as working with topoi.

%% example: open graphs
\begin{example}
  Consider the
  adjunction $$\adjunction{\Graph}{L}{R}{\Set}$$ with $ L $
  the discrete graph functor and $ R $ the functor that
  forgets the graph edges.  Structured cospans here are open
  graphs, that is graphs equipped with two subset of nodes,
  one serves as inputs and another, which is not necessarily
  disjoint, serves as outputs. \input{assets/openGraph1.tex}
  Connect these open graphs by gluing like-nodes
  together. This results in \input{assets/openGraph2.tex}
\end{example}

In Lack and Soboci\'{n}ski axiomatisation of DPO rewriting,
rewriting is done on the \emph{objects} of a category, not
the arrows.  Therefore, to rewrite structured cospans, we
require a category where the structured cospans are
objects and so we are obliged to define morphisms of
structured cospans. The expected definition is given.

% define L-structured cospan morphism
\begin{definition} \label{df:morph-of-strcsp}
  A morphism from $ La \to x \gets Lb $ to
  $ Lc \to y \gets Ld $ is a triple of arrows $ ( f,g,h ) $
  fitting into the commuting diagram
  \input{assets/morphismStrCsp.tex} There is a category,
  denoted by $ _L \StrCsp $, whose objects are $ L
  $-structured cospans and whose arrows are their morphisms.
\end{definition}

At this point, certain readers may have observed that
structured cospans fit as objects into one category and as
arrows into another, thus making it likely they fit into a
double category.  Indeed, they do.  In fact, they fit into a
symmetric monoidal double category which Baez and Courser
discuss.  We, however, are uninterested in this for our
purposes. 

We now come to the first of our main results: that
$ _{L}\StrCsp $ is a topos. This result is critical for our
theory because it allows the introduction of rewriting onto
structured cospans.

%% structured cospans form a topos
\begin{theorem} \label{thm:strcsp-istopos}
  Given an adjunction $$\adjunction{\X}{L}{R}{\A}$$ between
  topoi with $ L $ preserving finite limits, the category
  $ _{L}\StrCsp $ is a topos.
\end{theorem}
\begin{proof}
  By adjointness, $ _{L}\StrCsp $ is equivalent to the
  category whose objects are cospans of form
  $ a \to Rx \gets b $ and morphisms are triples
  $ ( f,g,h ) $ fitting into the commuting diagram
  \input{assets/morphismRStrCsp.tex} This, in turn, is
  equivalent to the comma category
  $ ( \A \times \A \downarrow \Delta R ) $ where
  $ \Delta \from \A \to \A \times \A $ is the diagonal
  functor, a right adjoint. Hence, $ \Delta R $ is a right
  adjoint making $ ( \A \times \A \downarrow \Delta R ) $
  an Artin glueing \cite{Wraith_ArtinGlue}, therefore
  a topos.
\end{proof}

Knowing that $ _L\StrCsp $ is a topos is enough for us
introduce rewriting structured cospans, but by pausing for
a moment, we see that $ _L\StrCsp $ is constructed
functorially.  

\begin{theorem} \label{thm:strcsp-isfunctorial}
  Denote by $ \Topos $ the category whose objects are topoi
  and whose arrows from $ \X $ to $ \A $ are adjoint
  pairs $$\adjunction{\X}{L}{R}{\A}$$ where $ L $ preserves
  finite limits (these arrows are geometric morphisms, a
  standard morphism between elementary topoi).  There is a
  functor
  \[
    _{(-)}\StrCsp_{(-)}
      \from [\bullet \to \bullet, \Topos ]
      \to   \Topos
  \]
  defined by \input{assets/functorialStrCsp1.tex} which is
  in turn given by \input{assets/functorialStrCsp2.tex} and
  \input{assets/functorialStrCsp3.tex}
\end{theorem}
\begin{proof}
  In light of Theorem \ref{thm:strcsp-istopos}, it suffices
  to show that $ \Theta \dashv \Theta' $ gives a geometric
  morphism.

  Denote the structured cospans
  $$[ m,n ] \colon La \to x \gets Lb$$ in $ _L\StrCsp $
  by $ \ell $ and $$[m',n'] \colon L'a' \to x' \gets L'b'$$ in
  $ _{ L' }\StrCsp $ by $ \ell' $. Denote the unit and
  counit for $F \dashv G$ by $ \eta $, $ \varepsilon $ and
  for $ F' \dashv G' $ by $ \eta' $, $ \varepsilon' $.  The
  assignments
  
  \begin{align*}
    \left( (f,g,h)\from\ell\to\Theta'\ell' \right)
      & \mapsto
        \left( (\epsilon'\circ F'f,
        \epsilon\circ Fg,
        \epsilon'\circ F'h )
        \from\Theta\ell\to\ell'\right) \\
    \left( (f',g',h')\from\Theta\ell\to\ell'\right)
      & \mapsto
        \left( (G'f'\circ\eta',Gg'\circ\eta,G'h'\circ\eta')
        \from\ell\to\Theta'\ell'\right) 
  \end{align*}
  
  give a bijection
  $ \hom (\Theta\ell,\ell') \simeq \hom (\ell,\Theta'\ell'
  )$. Moreover, it is natural in $\ell$ and $\ell'$. This
  rests on the natural maps $\eta$, $\epsilon$, $\eta'$, and
  $\epsilon'$. The left adjoint $\Theta'$ preserves finite
  limits because they are taken pointwise and $ L $, $ F $,
  and $ F' $ all preserve finite limits.
\end{proof}

With this theorem, we have brought forth various categories
of the form $ _L\StrCsp $ where $ L $ runs through finite
limit preserving left adjoints.  For reference, we refer to
such categories as structured cospan categories.  This
leaves us wanting to organize structured cospan categories
into some kind of structure, say a 2-category.  This is
easily accomplished using the following as our 1-arrows.

\begin{definition} \label{def:str-csp-functor}
  A \df{functor of structured cospan categories} is a pair
  of finitely continuous and cocontinuous functors
  $ F \from \X \to \X' $ and $ G \from \A \to \A' $ such
  that $ FL=L'F $ and $ GR = R'F $.
\end{definition}

Structured cospan categories along with their functors and
natural transformations form a 2-category $ \SStrCsp
$. However, we leave this 2-category here and more onwards
towards our intended goal: rewriting structured cospans.

%% =====================================================
\section{Structured cospan rewrites for a double category}
\label{sec:DblCat}
%% =====================================================

\Daniel{Cover what a grammar is and organize them into a double
category a la FineRewrite. Uncertain to include: interchange
law, symmetric monoidal structure. Just point to thesis?
Dno't call things FineRewrite, just Rewrite.}

In this chapter, we introduce a theory of fine rewriting to
structured cospans.  Rewriting is \emph{fine}
when the rewrite rules are spans with monic legs.  Our
primary goal is to define a double category whose squares
are fine rewrites of structured cospans.  The rough idea is
that this double category, denoted $ _L\RRRewrite $, has
interface types for objects, structured cospans for
horizontal arrows, isomorphisms of interface objects for
vertical arrows, and fine rewrite rules of structured
cospans for squares. We prove in Proposition
\ref{thm:fine-rewrite-double-cat} that $ _L\RRRewrite $
actually is a double category. The first step to proving
this is to ensure the fine rewrite rules are suitable squares for
our double category, we define them as follows.

\begin{definition}[Fine rewrite]
  A \df{fine rewrite of structured cospans} is an
  isomorphism class of spans of structured cospans of the
  form \input{assets/spanStrCsp.tex} The marked arrows are
  monic.
\end{definition}

In a double category, the squares have two composition
operations.  Horizontal composition uses pushout as is
typical with cospan categories. The vertical composition
uses pullback as is typical in span categories.  But because
there are no higher order arrows traversing the squares in a
double category, and because pushouts and pullbacks are only
defined up to isomorphism, we take isomorphism classes of
structured cospan rewrite rules.  With the squares of
$ \RRRewrite $ defined, we can introduce the two composition
operations.

\begin{definition} \label{def:hor-vert-composition}
  The \df{horizontal composition} of fine rewrite rules is
  given by \input{assets/horComposition1.tex} and
  \input{assets/horComposition.tex}

  The \df{vertical composition} of fine rewrite rules is
  \input{vertComposition.tex}
\end{definition}

We defined $ \hcirc $ and $ \vcirc $ using representatives
of isomorphism classes, however this operation is
well-defined. It is less clear, however, that these
operations preserve the monic arrows in the fine rewrites of
structured cospans.  In Proposition
\ref{thm:comp-preserve-monic}, we show that horizontal and
vertical composition do preserve these monic arrows. To
prove this, we require the following lemma.

\begin{lemma}
  \label{thm:quotient-map-monic-pushout}
  The diagram \input{assets/quotientMapMonicPushout1.tex}
  induces a pushout
  \input{assets/quotientMapMonicPushout2.tex} such that the
  canonical arrows $ \gamma $ and $ \gamma' $ are monic.
\end{lemma}

\begin{proof}
  The universal property of coproducts implies
  that $ \gamma $ factors through $ x' + z $ as in
  the diagram \input{assets/quotientMapMonicPushout3.tex}
   
  It is straightforward to check that both squares are
  pushouts. By Lemma \ref{lem:adhesive-properties}, it
  follows that $ \gamma $ is monic.

  Diagram \ref{eq:qmmp-2} commutes because of the universal
  property of coproducts.  To see that it is a pushout,
  arrange a cocone
  \input{assets/quotientMapMonicPushout4.tex}
  
  Denote by $ \iota_x $ any map that includes $ x $.  Then
  $ \psi' \iota_{x'} $, $ \psi' \iota_{z'} $, and $ c $ form
  a cocone under the span $ x' \gets y' \to z' $ from the
  bottom face of Diagram \ref{eq:qmmp-1}. This induces the
  canonical map $ \psi'' \from x'+_{y'} z' \to c $. It
  follows that
  $ \psi' \iota_{x'} = \psi'' \rho' \iota_{x'} $ and
  $ \psi' \iota_{z'} = \psi'' \rho' \iota_{z'} $. Therefore
  $ \psi' = \psi'' \rho' $ by the universal property of
  coproducts.

  Furthermore, $ \psi \rho \iota_z $,
  $ \psi \rho \iota_z $, and $ c $ form a cocone
  under the span $ x \gets y \to z $ on the top
  face of Diagram \ref{eq:qmmp-1}. then
  $ \psi \rho \iota_x = \psi' \gamma \iota_x =
  \psi'' \rho' \gamma \iota_x = \psi'' \psi' \rho
  \iota_x $ and
  $ \psi \rho \iota_z = \psi' \gamma \iota_z =
  \psi'' \rho' \gamma \iota_z = \psi'' \gamma'
  \rho \iota_z $ meaning that both $ \psi $ and
  $ \psi'' \psi' $ satisfy the canonical map
  $ x+_yz \to d $. Hence $ \psi = \psi'' \psi' $.

  The universality of $ \psi'' $ with respect to
  Diagram \ref{eq:qmmp-3} follows from the
  universality of $ \gamma'' $ with respect to
  $ x'+_{y'}z' $.
\end{proof}

\begin{lemma} \label{thm:comp-preserve-monic}
  Horizontal and vertical composition of fine
  rewrites are fine rewrites.
\end{lemma}

\begin{proof}
  We can see that the span of cospan obtained by horizontal
  composition of fine rewrites \input{assets/compPreserveMonic1.tex}
  
  is again a fine rewrite, that is the arrows
  $ w +_{Le} x \to u+_{Lb} v $ and
  $ w +_{Le} x \to y +_{Lh} z $ are monic, by applying Lemma
  \ref{thm:quotient-map-monic-pushout} to the diagrams \input{assets/compPreserveMonic2.tex}
  
  The result for vertical composition
  \input{assets/compPreserveMonic3.tex} holds because
  pullback preserves monomorphisms.
\end{proof}

With horizontal and vertical composition in hand, we
construct the double category $ _L\FFFineRewrite $.
Actually, we delay discussing the interchange law until
Section \ref{sec:interchange-law} because it is difficult
enough to warrant its own section.

\begin{proposition}
\label{thm:rewrite-double-cat}
  Let
  \[
    \adjunction{\X}{L}{R}{\A}
  \]
  be a adjunction with $ L $ preserving pullbacks.  There is
  a double category $ _L\FFFineRewrite $ whose objects are
  the $ \A $-objects, horizontal arrows of type $ a \to b $
  are structured cospans $ La \to x \gets Lb $, vertical
  arrows are spans in $ \A $ with invertible arrows, and
  squares are rewrites of structured cospans
  \input{assets/rewriteDoubleCat1.tex}
\end{proposition}

\begin{proof}
  This proof requires we check the axioms of a double
  category as laid out in Definition \ref{def:dbl-cat}. For
  simplicity, we denote $_L\FFFineRewrite$ by $\RRR $ in
  this proof.

  The object category $\RRR_0$ is given by objects of $\A$
  and isomorphism classes of spans in $\A$ such that each
  leg is an isomorphism.  The arrow category $\RRR_1$ has as
  objects the structured cospans
  \[
    La \to x \gets La'
  \]
  and as morphisms the fine rewrites of structured cospans.
	
  The functor $U \from \RRR_0 \to \RRR_1$ acts on objects by
  mapping $a$ to the identity cospan on $La$ and on
  morphisms by mapping $La \gets Lb \to Lc$, whose legs are
  isomorphisms, to the square
  \input{assets/rewriteDoubleCat2.tex}
  
  The functor $S \from \RRR_1 \to \RRR_0$ acts on objects by
  sending $La \to x \gets La'$ to $a$ and on morphisms by
  sending a square \input{assets/rewriteDoubleCat3.tex}
  
  to the span $ La \gets Lb \to Lc $. The functor $T$ is
  defined similarly sends an object \[ La \to x \gets La' \]
  of $ \RRR_1 $ to $ a' $ a square
  \input{assets/rewriteDoubleCat4.tex} to the span
  $ La' \gets Lb' \to Lc' $.
  
  The horizontal composition functor
  \[
    \odot \from \RRR_1 \times_{\RRR_0} \RRR_1 \to
    \RRR_1
  \]
  acts on objects by composing cospans with pushouts in the
  usual way.  It acts on morphisms by
  \input{assets/rewriteDoubleCat5.tex}
  
  Section \ref{sec:interchange-law} is devoted to proving
  that $\odot$ is functorial, that is, it preserves
  composition.  It is straightforward to check that the
  required equations are satisfied.  The associator and
  unitors are given by natural isomorphisms that arise from
  universal properties.
\end{proof}

And now, our double category of fine rewrites is defined. It
remains to prove the interchange law, which we do next.

%% ==========================================================
%% Decompositing Systems
%% ==========================================================
\section{The language of structured cospans}
\label{sec:structural-induction}

\Daniel{ Outline
  \begin{enumerate}
  \item Introduce grammars and language of structured cospans.
  \item Show that the Language functor characterizes the
    rewriting relation on a grammar of structured cospans.
  \end{enumerate}
}

The idea of decomposing a whole into parts has long been
useful. It exists across human endeavors, be it
academic, artistic, or artisanal. A biologist decomposes
life into genuses and species. A literary critic
decomposed a play into acts and scenes. A sommelier
decomposes a wine into color, viscosity, aroma, and
taste. In this chapter, as do the biologist, critic, and
sommelier, we too decompose. Though for us, we decompose a
closed system into open sub-systems.

Given that this paper fits into a larger wave of research
into applying category theory to compositional systems, we
place decomposition into this context.  A strong
motivation in this wave of research is to build a toolbox
with which to study complex systems by decomposing them into
simpler components and studying those instead. In a truly
compositional system, information gleaned from the
components can be aggregated to give infomation about the
original system.

As mathematicians, we must bring rigor to our
decomposition. In this chapter, we do just that. We start
by formalizing closed systems as structured cospans with an
empty interface $ 0 \to x \gets 0 $. Then,
using the fine rewriting paradigm from Chapter
\ref{sec:fine-rewriting}, we place structured cospans into
the double category $ _L \FFFineRewrite $ as horizontal
1-arrows.  To decompose a closed system $$L0 \to x \gets
L0$$ is to write an arrow as a composite of arrows
\[
  L0 \to x_1 \gets La_1 \to x_2 \gets La_2
  \dotsm La_{n-1} \to x_n \gets L0
\]
We use such decompositions to prove our main result which states that two structured cospans
\[
  L0 \to x \gets L0
  \quad \text{and} \quad
  L0 \to x' \gets L0
\]
are equivalent precisely when there is a square between
them.  We interpret this result in three ways.

\begin{enumerate}
\item It shows that the rewriting relation for a closed system
  is functorial and is characterized using squares in a double
  category.
\item A closed system decomposes into open systems, and
  simplifying each open system simplifies the composite
  closed system.  
\item Open systems provide a local perspective on the closed
  perspective via this decomposition.
\end{enumerate}

There are two main thrusts to this proof.  The first
generalizes a classification of formal graph grammars given
by Ehrig, et.~al. \cite{Ehrig_GraphGram}. This is
Theorem \ref{thm:production-same-rewrite-relation-as-discrete}.
Gadducci and Heckel proved this in the case of graphs
\cite{Gadd_IndGraphTrans}, but our result generalizes
this to structured cospans. Our proof mirrors theirs.

%% =========================================
\section{Rewriting structured cospans}
\label{sec:RewritingStrCsp}
%% =========================================

\Daniel{Generalize gadducci/heckle's theorem.  Place it into
  the ACT context.}

Equipped with knowledge about when grammars and their
underlying discrete grammars generate the same rewriting
relation, we continue towards goal of decomposing closed
systems. First, we revisit Section \ref{sec:rewriting-topoi}
to get some facts about grammars. We then obtain the
language associated to a grammar in a functorial
way. Finally, we show how to decompose into open subsystems a given system
equipped with a grammar. 

Recall the category $ \Gram $.  The objects of $ \Gram $ are
pairs $ ( \T , P ) $ where $ \T $ is a topos and $ P $ is a
set of rewrite rules in $ \T $.  The arrows
$ (\T , P) \to ( \T' , P' )$ of $ \Gram $ are
rule-preserving functors $ \T \to \T' $.  Our interest now
lies in the full subcategory of structured cospan grammars
$ \StrCspGram $ whose objects are the grammars of form
$ ( _L \StrCsp , P ) $ where $ P $ consists of rewrites of
structured cospans, meaning they have the form
\input{assets/strCspRewriteForm.tex} and the left adjoint
$ L $ has a monic counit.

It is on this category $ \StrCspGram $ that we define a
functor encoding the rewrite relation to each grammar. We
denote this functor
\[
  \Lang \from \StrCspGram \to \DblCat
\]
where $ \Lang $ is short for `language'. This is an
appropriate term as this functor provides \emph{(i)} the
terms formed by connecting together open systems (instead
of, in linguistics, concatenating units of syntax) and
\emph{(ii)} the rules governing how to interchange open
systems (instead of parts of speech). To help visualize
this, we sketch a simple example.

\begin{example}
  Start with the, by now familiar, adjunction
  \[
    \adjunction{\RGraph}{L}{R}{\Set}
  \]
  For this $ L $, $ _L \StrCsp $ is the category of open
  graphs.  Make a grammar from $ _L \StrCsp $ by defining a
  $ P $ to have the single rule \input{singleRuleGrammar1.tex}

  The language associated to this grammar consists of all
  open graphs. The rewrite relation says $ \deriv{g}{h} $ if
  we obtain $ h $ be removing loops from $ g $. We
  illustrate this with the following square in the double
  category $ \Lang ( _L \StrCsp , P )
  $. \input{assets/singleRuleGrammar2.tex}
  
\end{example}

To actually construct $ \Lang $, we use functors
$ D \from \StrCspGram \to \StrCspGram $ and
$ S \from \StrCspGram \to \DblCat $. Roughly, $ D $ sends a
grammar $ ( _L \StrCsp , P ) $ to all of the rewrite rules
derived from $ P $ and $ S $ generates a double category on
the squares obtained from the rewrite rules of a grammar
$ ( _L \StrCsp , P ) $. In this way, we get the language of
a grammar as a double category where the squares are the
rewrite rules.  The next lemma defines $ D $ and gives some
of its properties.

\begin{lemma}
  There is an idempotent functor
  $ D \from \StrCspGram \to \StrCspGram $ defined as
  follows. On objects define $ D ( _{L}\StrCsp , P ) $ to be
  the grammar $ ( _{L} \StrCsp , P_D) $, where $ P_D $
  consists of all rules $ \spn{g}{h}{d} $ witnessing the
  relation $ \dderiv{g}{h} $ with respect to
  $ ( _{L}\StrCsp , P ) $. On arrows, define
  $ DF \from D( _{L}\StrCsp , P ) \to D( _{L'}\StrCsp , Q )
  $ to be $ F $.  Moreover, the identity on $ \StrCspGram $
  is a subfunctor of $ D $.
\end{lemma}

\begin{proof}
  That $ D ( _{L}\StrCsp , P ) $ actually gives a grammar
  follows from the fact that pushouts respect monics in a
  topos \cite[Lem.~12]{LackSobo_Adhesive}.
  
  To show that $ \D $ is idempotent, we show that for any
  grammar $ ( _{L}\StrCsp , P ) $, we have
  $ D ( _{L}\StrCsp , P ) = DD ( _{L}\StrCsp , P ) $.  Rules
  in $ DD ( _{L}\StrCsp , P ) $ appear in the bottom row of a
  double pushout diagram whose top row is a rule in
  $ D ( _{L}\StrCsp , P ) $, which in turn is the bottom row
  of a double pushout diagram whose top row is in
  $ ( _{L}\StrCsp , P ) $. Thus, a rule in
  $ DD ( _{L}\StrCsp , P ) $ is the bottom row of a double
  pushout diagram whose top row is in
  $ ( _{L}\StrCsp , P ) $. See Figure \ref{fig:idempotentD}.

  \input{assets/indempotentD.tex}

  The identity is a subfunctor of $ D $ because
  $ \dderiv{\ell}{r} $ for any production
  $ \spn{\ell}{k}{r} $ in $ ( _{L}\StrCsp , P ) $ via a
  triple of identity arrows. Hence there is a monomorphism
  \[
    ( _L \StrCsp , P ) \to
    D ( _L \StrCsp , P )
  \]
  induced from the identity functor on $ _L\StrCsp $.
\end{proof}

In this lemma, we have created a functor $ D $ that sends a
grammar to a new grammar consisting of
all derived rules.  That $ D $ is idempotent means that all
rules derived from $ P $ can be derived directly; multiple
applications of $ D $ are unnecessary.  That the identity is
a subfunctor of $ D $ means that set of the derived rules
$ P_D $ contains the set of initial rules $ P $.

The next stage in defining $ \Lang $ is to define
$ S \from \StrCspGram \to \DblCat $. On objects, let
$ S ( _L \StrCsp , P ) $ be the sub-double category of
$ _L \SSStrCsp $ generated by the rules in $ P $ considered
as squares.  On arrows, $ S $ sends
\[
  F \from ( _{L}\StrCsp , P ) \to ( _{L'} \StrCsp , P' )
\]
to the double functor defined that extends the mapping
between the generators of $ S ( _{L}\StrCsp , P ) $ and
$ S ( _{L'}\StrCsp , P' ) $.  This preserves composition because
$ F $ preserves pullbacks and pushouts. 

\begin{definition}(Language of a grammar)
  The \df{language functor} is defined to be
  $ \Lang \coloneqq SD $. 
\end{definition}

To witness the rewriting relation on a closed system as a
square in a double category, we require this next lemma
that formalizes the analogy between rewriting the disjoint
union of systems and tensoring squares.

\begin{lemma} \label{thm:rewrite-rel-is-additive}
  If $ \deriv{x}{y} $ and $ \deriv{x'}{y'} $, then
  $ \deriv{x+x'}{y+y'} $
\end{lemma}

\begin{proof}
  If the derivation $ \deriv{x}{y} $ comes from a string of
  double pushout diagrams
  \input{assets/rewriteRelAdditive1.tex} and the derivation
  $ \deriv{x'}{y'} $ comes from a string of double pushout
  diagrams \input{assets/rewriteRelAdditive2.tex} realize
  $ \deriv{x+x'}{y+y'} $ by
  \input{assets/rewriteRelAdditive3.tex}
\end{proof}

As promised, we can now decompose closed systems into open
systems. For this, we need a topos of closed systems $ \X $
equipped with a grammar $ ( \X , P ) $. The closed systems
need interfaces, meaning we need to introduce an adjunction
\[
  \adjunction{\X}{L}{R}{\A}
\]
where $ L $ preserves pullbacks and has a monic counit. At
this point, the material from the previous section
returns. This adjunction gives a discrete comonad $ \flat
\bydef LR $ from which we form the discrete
grammar $ ( \X, P_\flat ) $. Now define the structured cospan
grammar $ ( _L \StrCsp , \hat{P_\flat} ) $ where $
\hat{P_\flat} $ contains the rule \input{assets/decompSquare}
for each rule $ \spn{\ell}{LRk}{r} $ of $ P_{\flat} $. We
use $ ( _L \StrCsp , \hat{P_\flat} ) $ to prove our main
theorem.

Before stating the theorem, we note that this theorem
generalizes work by Gadducci and Heckel
\cite{Gadd_IndGraphTrans} whose domain of
inquiry was graph rewriting. The arc of our
proof follows theirs.

\begin{theorem} \label{thm:inductive-rewriting}
  Fix an adjunction $ (L \dashv R) \from \X \lrto \A $ with
  monic counit. Let $ ( \X , P ) $ be a grammar such that
  for every $ \X $-object $ x $ in the apex of a production
  of $ P $, the lattice $ \Sub (x) $ has all meets. Given
  $ g $, $ h \in \X $, then $ \deriv{g}{h} $ in the
  rewriting relation for a grammar $ ( \X , P ) $ if and
  only if there is a square
  \input{assets/inductiveRewriting1.tex} 
  in the double category $ \Lang ( _{L}\StrCsp , \hat{P_\flat} ) $.
\end{theorem}

\begin{proof}
  We show sufficiency by inducting on the length of the
  derivation. If $ \deriv{g}{h} $ in a single step, meaning
  that there is a diagram
  \input{assets/inductiveRewriting2.tex}
  then the desired square is the horizontal composition of
  \input{assets/inductiveRewriting3.tex}
  
  The left square is a generator and the right square is the
  identity on the horizontal arrow $ \csp{LRk}{d}{L0}
  $. The square for a derivation
  $ \dderiv{\deriv{g}{h}}{j} $ is the vertical composition
  of
  \input{assets/inductiveRewriting4.tex}
  
  The top square is from $ \deriv{g}{h} $ and the second
  from $ \dderiv{h}{j} $.

  Conversely, proceed by structural induction on the
  generating squares of
  $ \Lang ( _{L}\StrCsp , \hat{P_\flat} ) $.  It suffices to
  show that the rewrite relation is preserved by vertical
  and horizontal composition by generating squares.  Suppose
  we have a square
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ w $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ x $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ y $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  % 
  corresponding to a derivation $ \deriv{w}{y} $. Composing
  this vertically with a generating square, which must have
  form
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ y $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ L 0 $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ z $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  %
  corresponding to a production $ \spn{y}{L0}{z} $ gives
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ w $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ L 0 $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ z $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  %
  which corresponds to a derivation
  $ \dderiv{\deriv{w}{y}}{z} $.  Composing horizontally with
  a generating square
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ \ell $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ LRk $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ r $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  % 
  corresponding with a production $ \spn{\ell}{LRk}{r} $
  results in the square
  %
  \begin{center}\begin{tikzpicture}
    \node (1t) at (0,4) {$ L 0 $};
    \node (2t) at (2,4) {$ w + \ell $};
    \node (3t) at (4,4) {$ L 0 $};
    \node (1m) at (0,2) {$ L 0 $};
    \node (2m) at (2,2) {$ x + LRk $};
    \node (3m) at (4,2) {$ L 0 $};
    \node (1b) at (0,0) {$ L 0 $};
    \node (2b) at (2,0) {$ y + r $};
    \node (3b) at (4,0) {$ L 0 $};
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2t) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (1m);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (3m);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2b) to node [] {\scriptsize{$  $}} (3b);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1t);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2t);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3t);
    \draw [cd] (1m) to node [] {\scriptsize{$  $}} (1b);
    \draw [cd] (2m) to node [] {\scriptsize{$  $}} (2b);
    \draw [cd] (3m) to node [] {\scriptsize{$  $}} (3b);
  \end{tikzpicture}\end{center}
  %
  But $ \deriv{w+\ell}{y+r} $ as seen in Lemma
  \ref{thm:rewrite-rel-is-additive}. 
\end{proof}

With this result, we have completely described the rewrite
relation for a grammar $ ( \X , P ) $ with squares in
$ \Lang ( _{L}\StrCsp, \hat{P_\flat} ) $ framed by the
initial object of $ \X $.  These squares are rewrites of a
closed system in the sense that the interface is empty.  We
can instead begin with a closed system $ x $ in $ \X $ as
represented by a horizontal arrow $ \csp{L0}{x}{L0} $ in
$ \Lang ( _{L}\StrCsp , \hat{P_\flat} ) $ and decompose it
into a composite of sub-systems, that is a sequence of
composable horizontal arrows

\begin{center}\begin{tikzpicture}
  \node (L0) at (0,0) {$ L0 $};
  \node (x1) at (1,1) {$ x_1 $};
  \node (La1) at (2,0) {$ La_1 $};
  \node (x2) at (3,1) {$ x_2 $};
  \node (La2) at (4,0) {$ La_2 $};
  \node () at (5,0) {$ \dotsm $};
  \node (Lan1) at (6,0) {$ La_{n-1} $};
  \node (xn) at (7,1) {$ x_n $};
  \node (L0') at (8,0) {$ L0 $};
  % 
  \draw [cd] 
    (L0) edge[] (x1)
    (La1) edge[] (x1)
    (La1) edge[] (x2)
    (La2) edge[] (x2)
    (Lan1) edge[] (xn)
    (L0') edge[] (xn);
\end{tikzpicture}\end{center}

Rewriting can be performed on each of these sub-systems
%
\begin{center}\begin{tikzpicture}
\begin{scope}[shift={(0,6)}]
  \node (1) at (0,4) {$ L0 $};
  \node (2) at (2,4) {$ x_1 $};
  \node (3) at (4,4) {$ La_1 $};
  \node (4) at (0,2) {$ L0 $};
  \node (5) at (2,2) {$ x'_1 $};
  \node (6) at (4,2) {$ La'_1 $};
  \node (7) at (0,0) {$ L0 $};
  \node (8) at (2,0) {$ x''_1 $};
  \node (9) at (4,0) {$ La''_1 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (1);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong  $}} (3);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong $}} (9);
\end{scope}
% 
\begin{scope}[shift={(6,6)}]
  \node (1) at (0,4) {$ La_{n-1} $};
  \node (2) at (2,4) {$ x_n $};
  \node (3) at (4,4) {$ L0 $};
  \node (4) at (0,2) {$ La_{n-1} $};
  \node (5) at (2,2) {$ x'_n $};
  \node (6) at (4,2) {$ L0 $};
  \node (7) at (0,0) {$ La_{n-1} $};
  \node (8) at (2,0) {$ x''_n $};
  \node (9) at (4,0) {$ L0 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (1);
  \draw [cd] (4) to node [left]
    {\scriptsize{$ \cong $}} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong  $}} (3);
  \draw [cd] (6) to node [right]
    {\scriptsize{$ \cong $}} (9);
\end{scope}
% 
\begin{scope}
  \node (1) at (0,4) {$ L0 $};
  \node (2) at (2,4) {$ y_1 $};
  \node (3) at (4,4) {$ La_1 $};
  \node (4) at (0,2) {$ L0 $};
  \node (5) at (2,2) {$ y'_1 $};
  \node (6) at (4,2) {$ La_1 $};
  \node (7) at (0,0) {$ L0 $};
  \node (8) at (2,0) {$ y''_1 $};
  \node (9) at (4,0) {$ La_1 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node[left]{$\cong$} (1);
  \draw [cd] (4) to node[left]{$\cong$} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node[right]{$\cong$} (3);
  \draw [cd] (6) to node[right]{$\cong$} (9);
\end{scope}
% 
\begin{scope}[shift={(6,0)}]
  \node (1) at (0,4) {$ La_{n-1} $};
  \node (2) at (2,4) {$ y_n $};
  \node (3) at (4,4) {$ L0 $};
  \node (4) at (0,2) {$ La_{n-1} $};
  \node (5) at (2,2) {$ y'_n $};
  \node (6) at (4,2) {$ L0 $};
  \node (7) at (0,0) {$ La_{n-1} $};
  \node (8) at (2,0) {$y''_n $};
  \node (9) at (4,0) {$ L0 $};
  \draw [cd] (1) to (2);
  \draw [cd] (3) to (2);
  \draw [cd] (4) to (5);
  \draw [cd] (6) to (5);
  \draw [cd] (7) to (8);
  \draw [cd] (9) to (8);
  \draw [cd] (4) to node [left] {$\cong$} (1);
  \draw [cd] (4) to node [left] {$\cong$} (7);
  \draw [>->] (5) to (2);
  \draw [>->] (5) to (8);
  \draw [cd] (6) to node [right] {$\cong$} (3);
  \draw [cd] (6) to node [right] {$\cong$} (9);
\end{scope}
% 
\node () at (5,2) {$ \dotsm $};
\node () at (2,5) {$ \vdots $};
\node () at (5,8) {$ \dotsm $};
\node () at (8,5) {$ \vdots $};
\end{tikzpicture}\end{center}
%
The composite of these squares is a rewriting of the
original system.

\bibliographystyle{plain}
\bibliography{assets/biblio}



\end{document}

